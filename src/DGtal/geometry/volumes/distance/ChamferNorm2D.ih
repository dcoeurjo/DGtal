/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file ChamferNorm2D.ih
 * @author David Coeurjolly (\c david.coeurjolly@liris.cnrs.fr )
 * Laboratoire d'InfoRmatique en Image et Systemes d'information - LIRIS (CNRS, UMR 5205), CNRS, France
 *
 * @date 2013/12/18
 *
 * Implementation of inline methods defined in ChamferNorm2D.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
template <typename TSpace>
inline
DGtal::ChamferNorm2D<TSpace>::~ChamferNorm2D()
{
}
///////////////////////////////////////////////////////////////////////////////
template <typename TSpace>
inline
DGtal::ChamferNorm2D<TSpace>::ChamferNorm2D(const unsigned int N)
{
  myDirections.reserve(N);
  myNormals.reserve(N);

  for(int i = 1; i < N; i++)
  {
    myDirections.push_back( Vector( i, N - i));
    myDirections.push_back( Vector( i, -(N - i)));
    
    myNormals.push_back( Vector(1,1) );
    myNormals.push_back( Vector(1,1) );
  }

  //Sorting
  std::sort(myDirections.begin(), myDirections.end(), myLessThanAngular);

  //Display
  std::copy( myDirections.begin(), myDirections.end(), std::ostream_iterator<Vector>(std::cout, "\n"));
}
///////////////////////////////////////////////////////////////////////////////
template <typename TSpace>
inline
DGtal::ChamferNorm2D<TSpace>::ChamferNorm2D(const Directions &aDirSet,
                                            const Directions &aNormalDirSet):
myDirections(aDirSet), myNormals(aNormalDirSet)
{
}
///////////////////////////////////////////////////////////////////////////////
template <typename TSpace>
inline
void
DGtal::ChamferNorm2D<TSpace>::selfDisplay ( std::ostream & out ) const
{
  out << "[ChamferNorm2D] mask size= "<<myDirections.size();
}
///////////////////////////////////////////////////////////////////////////////
template <typename TSpace>
inline
bool
DGtal::ChamferNorm2D<TSpace>::isValid() const
{
  return true;
}
///////////////////////////////////////////////////////////////////////////////
template <typename TSpace>
inline
typename DGtal::ChamferNorm2D<TSpace>::Abscissa
DGtal::ChamferNorm2D<TSpace>::getLowerRayIntersection(const Vector &aP, const Vector &aQ,
                                                      const Point &Lmin, const Point &Lmax,
                                                      const Dimension aDimension) const
{
  ASSERT(Lmin[aDimension] < Lmax[aDimension]);
  ASSERT(Lmin[(aDimension+1) %2] == Lmax[(aDimension+1)%2]);
  
  //trace.info() <<"     Computing intersection ("<<aP<<" ," <<aQ << ")  "<<std::endl;
  double slope, y;
  if (aDimension == 1)
  {
    ASSERT( (aQ[0] - aP[0]) != NumberTraits<Abscissa>::ZERO);
    slope = (aQ[1]-aP[1])/static_cast<double>((aQ[0] - aP[0]));
    y=0.0;
    
    y = slope * Lmin[0] + aP[1] - slope*aP[0];
    //trace.info()<<"y="<<y<<" ";
    /*if ( y < NumberTraits<Abscissa>::castToDouble(Lmin[1]))
     return Lmin[1];
     if ( y > NumberTraits<Abscissa>::castToDouble(Lmax[1]))
     return Lmax[1];
     */
    
    return static_cast<Abscissa>( floor(y));
  }
  else
  {
    ASSERT( (aQ[0] - aP[0]) != NumberTraits<Abscissa>::ZERO);
    slope = (aQ[1]-aP[1])/static_cast<double>((aQ[0] - aP[0]));
    double x = (Lmin[1] - aP[1] + slope*aP[0]) / slope;
    //trace.info()<<"y="<<y<<" ";
    /*  if ( x < NumberTraits<Abscissa>::castToDouble(Lmin[0]))
     return Lmin[0];
     if ( x > NumberTraits<Abscissa>::castToDouble(Lmax[0]))
     return Lmax[0];
     */
    return static_cast<Abscissa>( floor(x));
  }
}
///////////////////////////////////////////////////////////////////////////////
template <typename TSpace>
inline
typename DGtal::ChamferNorm2D<TSpace>::Vector
DGtal::ChamferNorm2D<TSpace>::getNormalFromCone(ConstIterator aCone) const
{
  size_t pos = aCone - myDirections.begin();
  return  myNormals[pos];
}
///////////////////////////////////////////////////////////////////////////////
template <typename TSpace>
inline
typename DGtal::ChamferNorm2D<TSpace>::Abscissa
DGtal::ChamferNorm2D<TSpace>::getUpperRayIntersection(const Vector &aP, const Vector &aQ,
                                                      const Point &Lmin, const Point &Lmax,
                                                      const Dimension aDimension) const
{
  ASSERT(Lmin[aDimension] < Lmax[aDimension]);
  ASSERT(Lmin[(aDimension+1) %2] == Lmax[(aDimension+1)%2]);

  // trace.info() <<"     Computing intersection ("<<aP<<" ," <<aQ << ")  "<<std::endl;
  double slope, y;
  if (aDimension == 1)
  {
    ASSERT( (aQ[0] - aP[0]) != NumberTraits<Abscissa>::ZERO);
    slope = (aQ[1]-aP[1])/static_cast<double>((aQ[0] - aP[0]));
    y=0.0;
 
    y = slope * Lmin[0] + aP[1] - slope*aP[0];
    //trace.info()<<"y="<<y<<" ";
    /*if ( y < NumberTraits<Abscissa>::castToDouble(Lmin[1]))
      return Lmin[1];
    if ( y > NumberTraits<Abscissa>::castToDouble(Lmax[1]))
      return Lmax[1];
     */
    
    return static_cast<Abscissa>( ceil(y));
  }
  else
  {
    ASSERT( (aQ[0] - aP[0]) != NumberTraits<Abscissa>::ZERO);
    slope = (aQ[1]-aP[1])/static_cast<double>((aQ[0] - aP[0]));
    double x = (Lmin[1] - aP[1] + slope*aP[0]) / slope;
   //trace.info()<<"y="<<y<<" ";
  /*  if ( x < NumberTraits<Abscissa>::castToDouble(Lmin[0]))
      return Lmin[0];
    if ( x > NumberTraits<Abscissa>::castToDouble(Lmax[0]))
      return Lmax[0];
    */
    return static_cast<Abscissa>( ceil(x));
  }
}
///////////////////////////////////////////////////////////////////////////////
template <typename TSpace>
inline
typename DGtal::ChamferNorm2D<TSpace>::ConstIterator
DGtal::ChamferNorm2D<TSpace>::getCone(const Vector &aDirection,
                                      ConstIterator aBegin,
                                      ConstIterator aEnd) const
{
  return std::upper_bound(aBegin, aEnd , canonicalRay(aDirection), myLessThanAngular) - 1;
}
///////////////////////////////////////////////////////////////////////////////
template <typename TSpace>
inline
typename DGtal::ChamferNorm2D<TSpace>::Vector
DGtal::ChamferNorm2D<TSpace>::canonicalRay(const Vector &aRay) const
{
  return Vector( (aRay[0]<0)? -aRay[0]:aRay[0], aRay[1] );
}
///////////////////////////////////////////////////////////////////////////////
template <typename TSpace>
inline
typename DGtal::ChamferNorm2D<TSpace>::Value
DGtal::ChamferNorm2D<TSpace>::operator()(const Point &P,
                                         const Point &Q) const
{
  Vector ray = canonicalRay(Q - P);
  
  //The cone
  ConstIterator it = getCone(ray, myDirections.begin(), myDirections.end());
  
  if ((it+1) == myDirections.end()) //aligned with Y axis
    --it;
  
  // v = dir_i/w_i
  Vector normalDir = getNormalFromCone(it);
  //distance as the scalar product with the associated normal
  return ray[0]*normalDir[0] + ray[1]*normalDir[1];
}
///////////////////////////////////////////////////////////////////////////////
template <typename TSpace>
inline
typename DGtal::ChamferNorm2D<TSpace>::ConstIterator
DGtal::ChamferNorm2D<TSpace>::shrinkPSubMask(ConstIterator aBegin,
                                             ConstIterator aEnd,
                                             const Point &aP, const Point &aQ,
                                             const Point &Lmin, const Point &Lmax,
                                             const Dimension aDimension,
                                             Point &midPoint,
                                             Point &nextMidPoint) const
{
  ASSERT(Lmin[aDimension] < Lmax[aDimension]);
  ASSERT(Lmin[(aDimension+1) %2] == Lmax[(aDimension+1)%2]);
  ASSERT(aP[(aDimension+1) %2] <=Lmin[(aDimension+1) %2]);
  ASSERT(aDimension == 1);
  ASSERT(aP[aDimension] != aQ[aDimension]);
  
  trace.beginBlock();
  trace.info()<<"Checking "<<*aBegin<<" -- "<< *aEnd << "  adimension="<<aDimension << " P="<<aP<<" Q="<<aQ<<std::endl;
  
  if ((aEnd- aBegin) > 1)
  {
    //Mid
    ConstIterator mid = aBegin + (aEnd - aBegin) / 2;
    
    trace.info() << "Mid direction= "<<*mid<<std::endl;
    trace.info() << "Mid+1 direction= "<<*(mid+1)<<std::endl;
    
    //beginPoint, endPoint
    Abscissa upperBegin,lowerEnd;
    midPoint = aP + (*mid);
    nextMidPoint = aP + *(mid+1);
    upperBegin = getUpperRayIntersection(aP, midPoint, Lmin, Lmax, aDimension);
    lowerEnd = getLowerRayIntersection(aP, nextMidPoint, Lmin, Lmax, aDimension);
    
    midPoint = Lmin;
    midPoint[aDimension] = upperBegin;
    nextMidPoint = Lmin;
    nextMidPoint[aDimension] = lowerEnd;
    
    //Distances w.r.t. Q, O(log(n)) per distance
    double dmidQ = this->operator()(aQ, midPoint);
    double dnextmidQ = this->operator()(aQ, nextMidPoint);

    
    //Distance w.r.t. P, O(1) per distance
    Vector normalDir = getNormalFromCone(mid);
    
    double dmidP = (midPoint[0]-aP[0])*normalDir[0] + (midPoint[1]-aP[1])*normalDir[1];
    normalDir = getNormalFromCone(mid);
    double dnextmidP = (nextMidPoint[0]-aP[0])*normalDir[0] + (nextMidPoint[1]-aP[1])*normalDir[1];
    
    trace.info() << "Instersections  mid="<<midPoint<<"  and mid+1="<< nextMidPoint << std::endl;
    trace.info() << "Distances : P->("<<dmidP<<","<<dnextmidP<<")   Q->("<<dmidQ<<","<<dnextmidQ<<")" << std::endl;
    bool PcloserMid = (dmidP < dmidQ);
    bool PcloserNextMid = (dnextmidP < dnextmidQ);
    
    trace.info() << " mid in "<< (PcloserMid ? "P":"Q") <<"  and mid+1 in "<< (PcloserNextMid ? "P":"Q")<<std::endl;
    
    //We have localized the cone
    if (PcloserMid != PcloserNextMid)
    {
      trace.endBlock();
      return mid;
    }
    
    //We decide to which direction we need to recurse
    if (PcloserMid && PcloserNextMid)
    {
      if (dmidQ < dnextmidQ)
      {
        trace.info()<<"Recurse down"<<std::endl;
        ConstIterator c = shrinkPSubMask(aBegin, mid, aP, aQ, Lmin, Lmax, aDimension, midPoint, nextMidPoint);
        trace.endBlock();
        return c;
      }
      else
      {
        trace.info()<<"Recurse up"<<std::endl;
        ConstIterator c = shrinkPSubMask(mid,aEnd,aP, aQ, Lmin, Lmax, aDimension, midPoint, nextMidPoint);
        trace.endBlock();
        return c;
      }
    }
    else
    {
      // mid and next in Q
      if (dmidP < dnextmidP)
      {
        trace.info()<<"Recurse down"<<std::endl;
        ConstIterator c = shrinkPSubMask(aBegin, mid, aP, aQ, Lmin, Lmax, aDimension, midPoint, nextMidPoint);
        trace.endBlock();
        return c;
      }
      else
      {
        trace.info()<<"Recurse up"<<std::endl;
        ConstIterator c = shrinkPSubMask(mid,aEnd,aP, aQ, Lmin, Lmax, aDimension, midPoint, nextMidPoint);
        trace.endBlock();
        return c;
      }
    }
  }
  
  return aBegin;
  trace.endBlock();
  
}
  ///////////////////////////////////////////////////////////////////////////////
template <typename TSpace>
inline
typename DGtal::ChamferNorm2D<TSpace>::ConstIterator
DGtal::ChamferNorm2D<TSpace>::shrinkP(ConstIterator aBegin,
                                      ConstIterator aEnd,
                                      const Point &aP, const Point &aQ,
                                      const Point &Lmin, const Point &Lmax,
                                      const Dimension aDimension,
                                      Point &midPoint,
                                      Point &nextMidPoint) const
{
  ASSERT(Lmin[aDimension] < Lmax[aDimension]);
  ASSERT(Lmin[(aDimension+1) %2] == Lmax[(aDimension+1)%2]);
  
  Point P,Q, Lm, LM;
  ConstIterator c;
  
  P = aP;
  Q = aQ;
  Lm = Lmin;
  LM = Lmax;
  
  if (aDimension == 1)
    if (aP[0] > Lmin[0])
    {
      //Putting P to the left of L
      P[0] = Lmin[0] - (aP[0] - Lmin[0]);
      Q[0] = Lmin[0] - (aQ[0] - Lmin[0]);
    }
  
  if (aDimension == 0)
  {
    //Symmetry x<->y
    Q[0] = aQ[1] ; Q[1] = aQ[0];
    P[0] = aP[1] ; P[1] = aP[0];
    Lm[0] = Lmin[1] ; Lm[1] = Lmin[0];
    LM[0] = Lmax[1] ; LM[1] = Lmax[0];
    trace.info() << "       swapping x<->y"<<std::endl;
    if (P[0] > Lm[0])
    {
      P[0] = Lm[0] - (P[0] - Lm[0]);
      Q[0] = Lm[0] - (Q[0] - Lm[0]);
    }
    
    c = shrinkPSubMask(aBegin, aEnd, P, Q, Lm, LM, 1,midPoint, nextMidPoint);
    
    //Setting back the midpoint
    trace.warning()<<"transform back"<<std::endl;
    Point mmid = midPoint;
    midPoint[0] = mmid[1] ; midPoint[1] = mmid[0];
    Point nextmid = nextMidPoint;
    nextMidPoint[0] = nextmid[1] ; nextMidPoint[1] = nextmid[0];
    
    return c;
  }
  
  // 1str half space (x>0, verticaL)
  c = shrinkPSubMask(aBegin, aEnd, P, Q, Lm, LM, 1,midPoint, nextMidPoint);
  return c;
}
///////////////////////////////////////////////////////////////////////////////
template <typename TSpace>
inline
typename DGtal::ChamferNorm2D<TSpace>::Abscissa
DGtal::ChamferNorm2D<TSpace>::getLowerVoronoiEdgeAbscissa(const Point &P, const Point &Q,
                                                          const Point &startingPoint, const Point &endPoint,
                                                          const Dimension aDimension) const
{
  Point midPointP,nextMidPointP;
  Point midPointQ,nextMidPointQ;
  
  ConstIterator itBeg = myDirections.begin();
  ConstIterator itEnd = myDirections.end();
  ConstIterator coneP = shrinkP(itBeg, itEnd, P, Q, startingPoint, endPoint, aDimension, midPointP, nextMidPointP);
  ConstIterator coneQ = shrinkP(itBeg, itEnd, Q, P, startingPoint,endPoint,aDimension, midPointQ, nextMidPointQ);

  Abscissa voroAbscissa;
  Vector normalP = getNormalFromCone(coneP);
  Vector normalQ = getNormalFromCone(coneQ);
  if (aDimension == 1)
    voroAbscissa = static_cast<Abscissa>(floor((double) (P[1]*normalP[1] - Q[1]*normalQ[1] - (startingPoint[0] - P[0])*normalP[0] + (startingPoint[0] - Q[0])*normalQ[0])  /(normalP[1] - normalQ[1])  ));
  else
    voroAbscissa = static_cast<Abscissa>(floor((double) (P[0]*normalP[0] - Q[0]*normalQ[0] - (startingPoint[1] - P[1])*normalP[1] + (startingPoint[1] - Q[1])*normalQ[1])  /(normalP[0] - normalQ[0])  ));
  
  return voroAbscissa;
}
///////////////////////////////////////////////////////////////////////////////
template <typename TSpace>
inline
bool
DGtal::ChamferNorm2D<TSpace>::hiddenBy(const Point &u, const Point &v, const Point &w,
                                       const Point &startingPoint, const Point &endPoint,
                                       const Dimension aDimension) const
{
  ASSERT( u[aDimension] < v[aDimension]);
  ASSERT( u[aDimension] < w[aDimension]);
  ASSERT( v[aDimension] < w[aDimension]);
  
  
  Abscissa x_uv = getLowerVoronoiEdgeAbscissa(u, v, startingPoint, endPoint, aDimension);
  trace.warning() << "x_uv=="<<x_uv<<std::endl;
  
  if ((x_uv < startingPoint[aDimension]) || (x_uv > endPoint[aDimension]))
    return true;
    
  Abscissa x_vw = getLowerVoronoiEdgeAbscissa(v, w, startingPoint, endPoint, aDimension);
  trace.warning() << "x_vw=="<<x_vw<<std::endl;
  if ((x_vw > endPoint[aDimension]))
    return true;
  
  
  return (x_uv > x_vw);

}
///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions                                        //
template <typename TSpace>
inline
std::ostream&
DGtal::operator<< ( std::ostream & out,
		  const ChamferNorm2D<TSpace> & object )
{
  object.selfDisplay( out );
  return out;
}
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
