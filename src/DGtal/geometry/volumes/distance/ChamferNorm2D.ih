/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file ChamferNorm2D.ih
 * @author David Coeurjolly (\c david.coeurjolly@liris.cnrs.fr )
 * Laboratoire d'InfoRmatique en Image et Systemes d'information - LIRIS (CNRS, UMR 5205), CNRS, France
 *
 * @date 2013/12/18
 *
 * Implementation of inline methods defined in ChamferNorm2D.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
#include "DGtal/arithmetic/IntegerComputer.h"
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
template <typename TSpace>
inline
DGtal::ChamferNorm2D<TSpace>::~ChamferNorm2D()
{
}
///////////////////////////////////////////////////////////////////////////////
template <typename TSpace>
inline
DGtal::ChamferNorm2D<TSpace>::ChamferNorm2D(const unsigned int N)
{
  myDirections.reserve(N);
  myNormals.reserve(N);
  int NN = N;

  IntegerComputer<typename Vector::Component> IC;
  
  myDirections.push_back( Vector(0,-1));

  for(int i = 1; i <= NN; i++)
    for(int j = -NN; j <= NN; j++)
    {
      typename Vector::Component gc = IC.gcd( i,j );
      if (gc == 1)
      myDirections.push_back( Vector( i,j) ) ;
    }
  
  //3-4 mask embedding
  int nbperSlots  = myDirections.size() / 4;
  for(unsigned int k=0; k < nbperSlots; k++)
    myNormals.push_back( Vector(1,-3));
  for(unsigned int k=0; k < nbperSlots; k++)
    myNormals.push_back( Vector(3,-1));
  for(unsigned int k=0; k < nbperSlots; k++)
    myNormals.push_back( Vector(3,1));
  for(unsigned int k=0; k < nbperSlots; k++)
    myNormals.push_back( Vector(1,3));
  
  //Sorting
  std::sort(myDirections.begin(), myDirections.end(), myLessThanAngular);

  //Display
  // std::copy( myDirections.begin(), myDirections.end(), std::ostream_iterator<Vector>(std::cout, "\n"));
  //trace.info()<<std::endl;
  //std::copy( myNormals.begin(), myNormals.end(), std::ostream_iterator<Vector>(std::cout, "\n"));
}
///////////////////////////////////////////////////////////////////////////////
template <typename TSpace>
inline
DGtal::ChamferNorm2D<TSpace>::ChamferNorm2D(const Directions &aDirSet,
                                            const Directions &aNormalDirSet):
myDirections(aDirSet), myNormals(aNormalDirSet)
{
}
///////////////////////////////////////////////////////////////////////////////
template <typename TSpace>
inline
void
DGtal::ChamferNorm2D<TSpace>::selfDisplay ( std::ostream & out ) const
{
  out << "[ChamferNorm2D] mask size= "<<myDirections.size();
}
///////////////////////////////////////////////////////////////////////////////
template <typename TSpace>
inline
bool
DGtal::ChamferNorm2D<TSpace>::isValid() const
{
  return true;
}
///////////////////////////////////////////////////////////////////////////////
template <typename TSpace>
inline
typename DGtal::ChamferNorm2D<TSpace>::Abscissa
DGtal::ChamferNorm2D<TSpace>::getLowerRayIntersection(const Vector &aP, const Vector &aQ,
                                                      const Point &Lmin, const Point &Lmax,
                                                      const Dimension aDimension) const
{
  ASSERT(Lmin[aDimension] < Lmax[aDimension]);
  ASSERT(Lmin[(aDimension+1) %2] == Lmax[(aDimension+1)%2]);
  
  //trace.info() <<"     Computing intersection ("<<aP<<" ," <<aQ << ")  "<<std::endl;
  double slope, y;
  if (aDimension == 1)
  {
    if ((aQ[0] - aP[0]) == NumberTraits<Abscissa>::ZERO)
    {
      if (aQ[1] > aP[1])
        return myInfinity;
      else
        return -myInfinity;
    }
    slope = (aQ[1]-aP[1])/static_cast<double>((aQ[0] - aP[0]));
    y=0.0;
    
    y = slope * Lmin[0] + aP[1] - slope*aP[0];
    //trace.info()<<"y="<<y<<" ";
    /*if ( y < NumberTraits<Abscissa>::castToDouble(Lmin[1]))
     return Lmin[1];
     if ( y > NumberTraits<Abscissa>::castToDouble(Lmax[1]))
     return Lmax[1];
     */
    
    return static_cast<Abscissa>( floor(y));
  }
  else
  {
    ASSERT( (aQ[0] - aP[0]) != NumberTraits<Abscissa>::ZERO);
    slope = (aQ[1]-aP[1])/static_cast<double>((aQ[0] - aP[0]));
    double x = (Lmin[1] - aP[1] + slope*aP[0]) / slope;
 
    if ((aQ[1] - aP[1]) == NumberTraits<Abscissa>::ZERO)
    {
      if (aQ[0] > aP[0])
        return myInfinity;
      else
        return -myInfinity;
    }
    
    //trace.info()<<"y="<<y<<" ";
    /*  if ( x < NumberTraits<Abscissa>::castToDouble(Lmin[0]))
     return Lmin[0];
     if ( x > NumberTraits<Abscissa>::castToDouble(Lmax[0]))
     return Lmax[0];
     */
    return static_cast<Abscissa>( floor(x));
  }
}
///////////////////////////////////////////////////////////////////////////////
template <typename TSpace>
inline
typename DGtal::ChamferNorm2D<TSpace>::Vector
DGtal::ChamferNorm2D<TSpace>::getNormalFromCone(ConstIterator aCone) const
{
  size_t pos = aCone - myDirections.begin();
  return  myNormals[pos];
}
///////////////////////////////////////////////////////////////////////////////
template <typename TSpace>
inline
typename DGtal::ChamferNorm2D<TSpace>::Abscissa
DGtal::ChamferNorm2D<TSpace>::getUpperRayIntersection(const Vector &aP, const Vector &aQ,
                                                      const Point &Lmin, const Point &Lmax,
                                                      const Dimension aDimension) const
{
  ASSERT(Lmin[aDimension] < Lmax[aDimension]);
  ASSERT(Lmin[(aDimension+1) %2] == Lmax[(aDimension+1)%2]);

  // trace.info() <<"     Computing intersection ("<<aP<<" ," <<aQ << ")  "<<std::endl;
  double slope, y;
  if (aDimension == 1)
  {
    if ((aQ[0] - aP[0]) == NumberTraits<Abscissa>::ZERO)
    {
      if (aQ[1] > aP[1])
        return myInfinity;
      else
        return -myInfinity;
    }
    slope = (aQ[1]-aP[1])/static_cast<double>((aQ[0] - aP[0]));
    y=0.0;
 
    y = slope * Lmin[0] + aP[1] - slope*aP[0];
    return static_cast<Abscissa>( ceil(y));
  }
  else
  {
    ASSERT( (aQ[0] - aP[0]) != NumberTraits<Abscissa>::ZERO);
    slope = (aQ[1]-aP[1])/static_cast<double>((aQ[0] - aP[0]));
    double x = (Lmin[1] - aP[1] + slope*aP[0]) / slope;
 
    if ((aQ[1] - aP[1]) == NumberTraits<Abscissa>::ZERO)
    {
      if (aQ[0] > aP[0])
        return myInfinity;
      else
        return -myInfinity;
    }

    
    return static_cast<Abscissa>( ceil(x));
  }
}
///////////////////////////////////////////////////////////////////////////////
template <typename TSpace>
inline
typename DGtal::ChamferNorm2D<TSpace>::ConstIterator
DGtal::ChamferNorm2D<TSpace>::getCone(const Vector &aDirection,
                                      ConstIterator aBegin,
                                      ConstIterator aEnd) const
{
  return std::upper_bound(aBegin, aEnd , canonicalRay(aDirection), myLessThanAngular) -1;
}
///////////////////////////////////////////////////////////////////////////////
template <typename TSpace>
inline
typename DGtal::ChamferNorm2D<TSpace>::Vector
DGtal::ChamferNorm2D<TSpace>::canonicalRay(const Vector &aRay) const
{
  return Vector( (aRay[0]<0)? -aRay[0]:aRay[0], aRay[1] );
}
///////////////////////////////////////////////////////////////////////////////
template <typename TSpace>
inline
typename DGtal::ChamferNorm2D<TSpace>::Value
DGtal::ChamferNorm2D<TSpace>::operator()(const Point &P,
                                         const Point &Q) const
{
  Vector ray = canonicalRay(Q - P);
  
  //The cone
  ConstIterator it = getCone(ray, myDirections.begin(), myDirections.end());
  
  // v = dir_i/w_i
  Vector normalDir = getNormalFromCone(it);
  //distance as the scalar product with the associated normal
  return ray[0]*normalDir[0] + ray[1]*normalDir[1];
}
///////////////////////////////////////////////////////////////////////////////
template <typename TSpace>
inline
typename DGtal::ChamferNorm2D<TSpace>::ConstIterator
DGtal::ChamferNorm2D<TSpace>::shrinkPSubMask(ConstIterator aBegin,
                                             ConstIterator aEnd,
                                             const Point &aP, const Point &aQ,
                                             const Point &Lmin, const Point &Lmax,
                                             const Dimension aDimension,
                                             Point &midPoint,
                                             Point &nextMidPoint) const
{
  ASSERT(Lmin[aDimension] < Lmax[aDimension]);
  ASSERT(Lmin[(aDimension+1) %2] == Lmax[(aDimension+1)%2]);
  ASSERT(aP[(aDimension+1) %2] <=Lmin[(aDimension+1) %2]);
  ASSERT(aDimension == 1);
  ASSERT(aP[aDimension] != aQ[aDimension]);
  
  //trace.beginBlock();
  //trace.info()<<"Checking "<<*aBegin<<" -- "<< *aEnd << "  adimension="<<aDimension << " P="<<aP<<" Q="<<aQ<<std::endl;
  
  if ((aEnd - aBegin) > 1)
  {
    //Mid
    ConstIterator mid = aBegin + (aEnd - aBegin) / 2;
    
    // trace.info() << "Mid direction= "<<*mid<<std::endl;
    // trace.info() << "Mid+1 direction= "<<*(mid+1)<<std::endl;
    
    //beginPoint, endPoint
    Abscissa upperMid,lowerNext;
    midPoint = aP + (*mid);
    nextMidPoint = aP + *(mid+1);
    upperMid = getUpperRayIntersection(aP, midPoint, Lmin, Lmax, aDimension);
    lowerNext = getLowerRayIntersection(aP, nextMidPoint, Lmin, Lmax, aDimension);
    
    midPoint = Lmin;
    midPoint[aDimension] = upperMid;
    nextMidPoint = Lmin;
    nextMidPoint[aDimension] = lowerNext;
    
    //Distances w.r.t. Q, O(log(n)) per distance
    double dmidQ = this->operator()(aQ, midPoint);
    double dnextmidQ = this->operator()(aQ, nextMidPoint);

    
    //Distance w.r.t. P, O(1) per distance
    Vector normalDir = getNormalFromCone(mid);
    
    double dmidP = (midPoint[0]-aP[0])*normalDir[0] + (midPoint[1]-aP[1])*normalDir[1];
    normalDir = getNormalFromCone(mid);
    double dnextmidP = (nextMidPoint[0]-aP[0])*normalDir[0] + (nextMidPoint[1]-aP[1])*normalDir[1];
    
    //  trace.info() << "Instersections  mid="<<midPoint<<"  and mid+1="<< nextMidPoint << std::endl;
    bool PcloserMid = (dmidP < dmidQ);
    bool PcloserNextMid = (dnextmidP < dnextmidQ);
    
    // trace.info() << "Distances : P->("<<dmidP<<","<<dnextmidP<<")   Q->("<<dmidQ<<","<<dnextmidQ<<")" << std::endl;
    //trace.info() << " mid in "<< (PcloserMid ? "P":"Q") <<"  and mid+1 in "<< (PcloserNextMid ? "P":"Q")<<std::endl;
    
    //We have localized the cone
    if (PcloserMid != PcloserNextMid)
    {
      //     trace.endBlock();
      return mid;
    }
    
    //We decide to which direction we need to recurse
    if (PcloserMid && PcloserNextMid)
    {
      if (aP[aDimension] < aQ[aDimension])
      {
        //trace.info()<<"Recurse up"<<std::endl;
        ConstIterator c = shrinkPSubMask(mid,aEnd,aP, aQ, Lmin, Lmax, aDimension, midPoint, nextMidPoint);
        //   trace.endBlock();
        return c;
      }
      else
      {
        // trace.info()<<"Recurse down"<<std::endl;
        ConstIterator c = shrinkPSubMask(aBegin, mid, aP, aQ, Lmin, Lmax, aDimension, midPoint, nextMidPoint);
        //    trace.endBlock();
        return c;
      }
    }
    else
    {
      // mid and next in Q
      if (aP[aDimension] < aQ[aDimension])
      {
        //trace.info()<<"Recurse down"<<std::endl;
        ConstIterator c = shrinkPSubMask(aBegin, mid, aP, aQ, Lmin, Lmax, aDimension, midPoint, nextMidPoint);
        //     trace.endBlock();
        return c;
      }
      else
      {
        //trace.info()<<"Recurse up"<<std::endl;
        ConstIterator c = shrinkPSubMask(mid,aEnd,aP, aQ, Lmin, Lmax, aDimension, midPoint, nextMidPoint);
        //   trace.endBlock();
        return c;
      }
    }
  }
  //Distance w.r.t. P, O(1) per distance
  
 /* double dmidP = this->operator()(aP, midPoint);
  double dnextmidP =  this->operator()(aP,nextMidPoint);
  double dmidQ = this->operator()(aQ, midPoint);
  double dnextmidQ =  this->operator()(aQ,nextMidPoint);
  */
  //  trace.info() << "Instersections  mid="<<midPoint<<"  and mid+1="<< nextMidPoint << std::endl;
  // bool PcloserMid = (dmidP < dmidQ);
  //bool PcloserNextMid = (dnextmidP < dnextmidQ);
  //trace.info() << "Distances : P->("<<dmidP<<","<<dnextmidP<<")   Q->("<<dmidQ<<","<<dnextmidQ<<")" << std::endl;
  //trace.info() << " mid in "<< (PcloserMid ? "P":"Q") <<"  and mid+1 in "<< (PcloserNextMid ? "P":"Q")<<std::endl;
  
  //trace.endBlock();
  return aBegin;
}
  ///////////////////////////////////////////////////////////////////////////////
template <typename TSpace>
inline
typename DGtal::ChamferNorm2D<TSpace>::ConstIterator
DGtal::ChamferNorm2D<TSpace>::shrinkP(ConstIterator aBegin,
                                      ConstIterator aEnd,
                                      const Point &aP, const Point &aQ,
                                      const Point &Lmin, const Point &Lmax,
                                      const Dimension aDimension,
                                      Point &midPoint,
                                      Point &nextMidPoint) const
{
  ASSERT(Lmin[aDimension] < Lmax[aDimension]);
  ASSERT(Lmin[(aDimension+1) %2] == Lmax[(aDimension+1)%2]);
  
  //Special case P in L
  if (aP[(aDimension +1)%2] == Lmin[(aDimension+1)%2])
  {
    //  trace.emphase() << "Special Case P on L"<<std::endl;
    midPoint = aP;
    nextMidPoint = aP;
    if (aP[aDimension] > aQ[aDimension])
      return aBegin;
    else
    {
      //We retrun the last cone (t,t+1) such that t+1 == aEnd
      ConstIterator preEnd =  aEnd - 1;
      return preEnd;
    }
  }
  
  Point P,Q, Lm, LM;
  ConstIterator c;
  
  P = aP;
  Q = aQ;
  Lm = Lmin;
  LM = Lmax;
  
  if (aDimension == 1)
    if (aP[0] > Lmin[0])
    {
      //Putting P to the left of L
      P[0] = Lmin[0] - (aP[0] - Lmin[0]);
      Q[0] = Lmin[0] - (aQ[0] - Lmin[0]);
    }
  
  if (aDimension == 0)
  {
    //Symmetry x<->y
    Q[0] = aQ[1] ; Q[1] = aQ[0];
    P[0] = aP[1] ; P[1] = aP[0];
    Lm[0] = Lmin[1] ; Lm[1] = Lmin[0];
    LM[0] = Lmax[1] ; LM[1] = Lmax[0];
    // trace.info() << "       swapping x<->y"<<std::endl;
    if (P[0] > Lm[0])
    {
      P[0] = Lm[0] - (P[0] - Lm[0]);
      Q[0] = Lm[0] - (Q[0] - Lm[0]);
    }
    
    c = shrinkPSubMask(aBegin, aEnd, P, Q, Lm, LM, 1,midPoint, nextMidPoint);
    
    //Setting back the midpoint
    // trace.warning()<<"transform back"<<std::endl;
    Point mmid = midPoint;
    midPoint[0] = mmid[1] ; midPoint[1] = mmid[0];
    Point nextmid = nextMidPoint;
    nextMidPoint[0] = nextmid[1] ; nextMidPoint[1] = nextmid[0];
    
    return c;
  }
  
  // 1str half space (x>0, verticaL)
  c = shrinkPSubMask(aBegin, aEnd, P, Q, Lm, LM, 1,midPoint, nextMidPoint);
  return c;
}
///////////////////////////////////////////////////////////////////////////////
template <typename TSpace>
inline
typename DGtal::ChamferNorm2D<TSpace>::Abscissa
DGtal::ChamferNorm2D<TSpace>::getLowerVoronoiEdgeAbscissa(const Point &P, const Point &Q,
                                                          const Point &startingPoint, const Point &endPoint,
                                                          const Dimension aDimension) const
{
  Point midPointP,nextMidPointP;
  Point midPointQ,nextMidPointQ;
  
  ConstIterator itBeg = myDirections.begin();
  ConstIterator itEnd = myDirections.end();
  ConstIterator coneP = shrinkP(itBeg, itEnd, P, Q, startingPoint, endPoint, aDimension, midPointP, nextMidPointP);
  //trace.info()<< "       CONEP DONE "<< *coneP<<std::endl;
  
  
  ConstIterator coneQ = shrinkP(itBeg, itEnd, Q, P, startingPoint,endPoint,aDimension, midPointQ, nextMidPointQ);
  //trace.info()<< "       CONE -Q DONE"<<std::endl;

  
  Abscissa voroAbscissa;
  Vector normalP = getNormalFromCone(coneP);
  Vector normalQ = getNormalFromCone(coneQ);
  
  //if ((aDimension == 1) && (startingPoint[0]==11))
  {
 /* trace.warning() << "midPoint P"<< midPointP<<" next = "<<nextMidPointP<<" coneP="<<*coneP<<std::endl;
  trace.warning() << "dist midPoint P"<< this->operator()(P,midPointP)<<" next = "<<this->operator()(P,nextMidPointP)<<std::endl;
  
  trace.warning() << "midPoint Q"<< midPointQ<<" next = "<<nextMidPointQ<<" coneQ="<<*coneQ<<std::endl;
  trace.warning() << "dist midPoint Q"<< this->operator()(Q,midPointQ)<<" next = "<<this->operator()(Q,nextMidPointQ)<<std::endl;

  trace.warning() << "normal P="<<normalP<<"   normal   Q="<<normalQ<<std::endl;
 */
  }
  
  if (aDimension == 1)
  {
    //Symmetry w.r.t. L is necessary
    if (P[0] > startingPoint[0])
      normalP[0] *= -1;
    if (Q[0] > startingPoint[0])
      normalQ[0] *= -1;
    
    if (normalP[1] == normalQ[1])
    {
      //same cone, Voro edge should be on cone extermities
      //We first recompute the cone edges
      Abscissa upperMid,lowerNext;
      Point midPointPP, nextMidPointPP;
      Point midPointQQ, nextMidPointQQ;
     /*
      midPointPP = P + (*coneP);
      nextMidPointPP = P + *(coneP+1);
      upperMid = getUpperRayIntersection(P, midPointPP, startingPoint, endPoint, aDimension);
      lowerNext = getLowerRayIntersection(P, nextMidPointPP, startingPoint, endPoint, aDimension);
      midPointPP = startingPoint;
      midPointPP[aDimension] = upperMid;
      nextMidPointPP = startingPoint;
      nextMidPointPP[aDimension] = lowerNext;
      
      midPointQQ = Q + (*coneQ);
      nextMidPointQQ = Q + *(coneQ+1);
      upperMid = getUpperRayIntersection(Q, midPointQQ, startingPoint, endPoint, aDimension);
      lowerNext = getLowerRayIntersection(Q, nextMidPointQQ, startingPoint, endPoint, aDimension);
      midPointQQ = startingPoint;
      midPointQQ[aDimension] = upperMid;
      nextMidPointQQ = startingPoint;
      nextMidPointQQ[aDimension] = lowerNext;
*/
   /*   trace.info()<< "SPECIAL NORMAL CONE CASE "<<std::endl;
      trace.info()<< "    CONEP = "<<midPointP<<" ("<< this->operator()(P,midPointP)<<")"<<"("<< this->operator()(Q,midPointP)<<") -  "
                  << nextMidPointP<<" ("<< this->operator()(P,nextMidPointP)<<")"<<"("<< this->operator()(Q,nextMidPointP)<<") "<<std::endl;
   
      trace.info()<< "    CONEQ = "<<midPointQ<<" ("<< this->operator()(P,midPointQ)<<") "<<"("<< this->operator()(Q,midPointQ)<<") - "
                  <<nextMidPointQ<<" ("<< this->operator()(P,nextMidPointQ)<<")"<<"("<< this->operator()(Q,nextMidPointQ)<<") "<<std::endl;
      
     */
      if (coneP == itBeg)  // and thus coneQ=itBeg
      {
        //Return lowest valid cone abscissa
        if ((nextMidPointP != P)  && (nextMidPointQ !=Q))   //P on
          return (nextMidPointQ[1]<nextMidPointP[1])? nextMidPointQ[1]:nextMidPointP[1];
        
        if (nextMidPointP == P)
          return nextMidPointQ[1];
        
        return nextMidPointP[1];
      }
    
      if ((coneP +1) == itEnd)  // and thus (coneQ+1)=itEnd
      {
        //Return highest valid cone abscissa
        if ((midPointP != P)  && (midPointQ !=Q))   //P on
          return (midPointQ[1]> midPointP[1])?  midPointQ[1] : midPointP[1];
        
        if (midPointP == P)
        {
          //trace.info()<< " midPointP===P trick"<<std::endl;
        return midPointQ[1];
        }
        return midPointP[1];
      }

      double dpm = this->operator()(P, midPointP);//, dpn = this->operator()(P,nextMidPointP);
      double dqm = this->operator()(Q, midPointQ);//   //same cone, Voro edge should be on cone extermities
                                                  //  trace.info()<< "SPECIAL NORMAL CONE CASE "<< dpm<<"  " <<dqm<<std::endl;
      if (dpm == dqm)
        return midPointP[1];
      else
        return nextMidPointP[1];
      
    }
    else
       voroAbscissa = static_cast<Abscissa>(floor((double) (P[1]*normalP[1] - Q[1]*normalQ[1] - (startingPoint[0] - P[0])*normalP[0] + (startingPoint[0] - Q[0])*normalQ[0])  /(normalP[1] - normalQ[1] )  ));
  }
  else
  {
    //Symmetry w.r.t. L if necessary
    //Symmetry x<->y
    
    Abscissa tmp = normalP[0];
    normalP[0] = normalP[1];
    normalP[1] = tmp;
    
    tmp = normalQ[0];
    normalQ[0] = normalQ[1];
    normalQ[1] = tmp;
    
    if (P[1] > startingPoint[1])
      normalP[1] *= -1;
    if (Q[1] > startingPoint[1])
      normalQ[1] *= -1;
    
    if (normalP[0] == normalQ[0])
    {
      //same cone, Voro edge should be on cone extermities
      double dpm = this->operator()(P, midPointP);//, dpn = this->operator()(P,nextMidPointP);
      double dqm = this->operator()(Q, midPointQ);//, dqn = this->operator()(Q,nextMidPointQ);
      if (dpm == dqm)
        return midPointP[0];
      else return nextMidPointP[0];
      
    }
    else voroAbscissa = static_cast<Abscissa>(floor((double) (P[0]*normalP[0] - Q[0]*normalQ[0] - (startingPoint[1] - P[1])*normalP[1] + (startingPoint[1] - Q[1])*normalQ[1])  /(normalP[0] - normalQ[0])  ));
  }
  return voroAbscissa;
}
///////////////////////////////////////////////////////////////////////////////
template <typename TSpace>
inline
bool
DGtal::ChamferNorm2D<TSpace>::hiddenBy(const Point &u, const Point &v, const Point &w,
                                       const Point &startingPoint, const Point &endPoint,
                                       const Dimension aDimension) const
{
  ASSERT( u[aDimension] < v[aDimension]);
  ASSERT( u[aDimension] < w[aDimension]);
  ASSERT( v[aDimension] < w[aDimension]);
  
  
  // trace.info()<<" HiddenBy: "<<u<< " -- "<< v<<" -- "<<w<< " ["<<startingPoint<<" - "<<endPoint<<"]"<<std::endl;
  
  Abscissa x_uv = getLowerVoronoiEdgeAbscissa(u, v, startingPoint, endPoint, aDimension);
  // trace.warning() << "x_uv=="<<x_uv<<std::endl;
  
  if ((x_uv > endPoint[aDimension]))
  {
    //    trace.info() <<" ==> outside1 ==> true"<<std::endl;
    return true;
  }
  
  Abscissa x_vw = getLowerVoronoiEdgeAbscissa(v, w, startingPoint, endPoint, aDimension);
  //trace.warning() << "x_vw=="<<x_vw<<std::endl;
  if ((x_vw < startingPoint[aDimension]))
  {
    //   trace.info() <<" ==> outside ==> true"<<std::endl;
    return true;
  }
  
 /* if (x_uv > x_vw)
      trace.info() <<" ==> true"<<std::endl;
  else
    trace.info() << " ===> false"<<std::endl;
  */return (x_uv > x_vw);

}
///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions                                        //
template <typename TSpace>
inline
std::ostream&
DGtal::operator<< ( std::ostream & out,
		  const ChamferNorm2D<TSpace> & object )
{
  object.selfDisplay( out );
  return out;
}
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
