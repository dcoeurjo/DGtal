/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file ChamferNorm2D.ih
 * @author David Coeurjolly (\c david.coeurjolly@liris.cnrs.fr )
 * Laboratoire d'InfoRmatique en Image et Systemes d'information - LIRIS (CNRS, UMR 5205), CNRS, France
 *
 * @date 2013/12/18
 *
 * Implementation of inline methods defined in ChamferNorm2D.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
template <typename TSpace>
inline
DGtal::ChamferNorm2D<TSpace>::~ChamferNorm2D()
{
}
///////////////////////////////////////////////////////////////////////////////
template <typename TSpace>
inline
DGtal::ChamferNorm2D<TSpace>::ChamferNorm2D(const unsigned int N)
{
  myDirections.reserve(N);
  myNormals.reserve(N);

  for(int i = 1; i < N; i++)
  {
    myDirections.push_back( Vector( i, N - i));
    myDirections.push_back( Vector( i, -(N - i)));
    
    myNormals.push_back( Vector(1,1) );
    myNormals.push_back( Vector(1,1) );
  }

  //Sorting
  std::sort(myDirections.begin(), myDirections.end(), myLessThanAngular);

  //Display
  std::copy( myDirections.begin(), myDirections.end(), std::ostream_iterator<Vector>(std::cout, "\n"));
}
///////////////////////////////////////////////////////////////////////////////
template <typename TSpace>
inline
DGtal::ChamferNorm2D<TSpace>::ChamferNorm2D(const Directions &aDirSet,
                                            const Directions &aNormalDirSet):
myDirections(aDirSet), myNormals(aNormalDirSet)
{
}
///////////////////////////////////////////////////////////////////////////////
template <typename TSpace>
inline
void
DGtal::ChamferNorm2D<TSpace>::selfDisplay ( std::ostream & out ) const
{
  out << "[ChamferNorm2D] mask size= "<<myDirections.size();
}
///////////////////////////////////////////////////////////////////////////////
template <typename TSpace>
inline
bool
DGtal::ChamferNorm2D<TSpace>::isValid() const
{
  return true;
}
///////////////////////////////////////////////////////////////////////////////
template <typename TSpace>
inline
typename DGtal::ChamferNorm2D<TSpace>::Abscissa
DGtal::ChamferNorm2D<TSpace>::getLowerRayIntersection(const Vector &aP, const Vector &aQ,
                                                      const Point &Lmin, const Point &Lmax,
                                                      const Dimension aDimension) const
{
  ASSERT(Lmin[aDimension] < Lmax[aDimension]);
  ASSERT(Lmin[(aDimension+1) %2] == Lmax[(aDimension+1)%2]);
  
  //trace.info() <<"     Computing intersection ("<<aP<<" ," <<aQ << ")  "<<std::endl;
  double slope, y;
  if (aDimension == 1)
  {
    ASSERT( (aQ[0] - aP[0]) != NumberTraits<Abscissa>::ZERO);
    slope = (aQ[1]-aP[1])/static_cast<double>((aQ[0] - aP[0]));
    y=0.0;
    
    y = slope * Lmin[0] + aP[1] - slope*aP[0];
    //trace.info()<<"y="<<y<<" ";
    /*if ( y < NumberTraits<Abscissa>::castToDouble(Lmin[1]))
     return Lmin[1];
     if ( y > NumberTraits<Abscissa>::castToDouble(Lmax[1]))
     return Lmax[1];
     */
    
    return static_cast<Abscissa>( floor(y));
  }
  else
  {
    ASSERT( (aQ[0] - aP[0]) != NumberTraits<Abscissa>::ZERO);
    slope = (aQ[1]-aP[1])/static_cast<double>((aQ[0] - aP[0]));
    double x = (Lmin[1] - aP[1] + slope*aP[0]) / slope;
    //trace.info()<<"y="<<y<<" ";
    /*  if ( x < NumberTraits<Abscissa>::castToDouble(Lmin[0]))
     return Lmin[0];
     if ( x > NumberTraits<Abscissa>::castToDouble(Lmax[0]))
     return Lmax[0];
     */
    return static_cast<Abscissa>( floor(x));
  }
}
///////////////////////////////////////////////////////////////////////////////
template <typename TSpace>
inline
typename DGtal::ChamferNorm2D<TSpace>::Abscissa
DGtal::ChamferNorm2D<TSpace>::getUpperRayIntersection(const Vector &aP, const Vector &aQ,
                                                      const Point &Lmin, const Point &Lmax,
                                                      const Dimension aDimension) const
{
  ASSERT(Lmin[aDimension] < Lmax[aDimension]);
  ASSERT(Lmin[(aDimension+1) %2] == Lmax[(aDimension+1)%2]);

  // trace.info() <<"     Computing intersection ("<<aP<<" ," <<aQ << ")  "<<std::endl;
  double slope, y;
  if (aDimension == 1)
  {
    ASSERT( (aQ[0] - aP[0]) != NumberTraits<Abscissa>::ZERO);
    slope = (aQ[1]-aP[1])/static_cast<double>((aQ[0] - aP[0]));
    y=0.0;
 
    y = slope * Lmin[0] + aP[1] - slope*aP[0];
    //trace.info()<<"y="<<y<<" ";
    /*if ( y < NumberTraits<Abscissa>::castToDouble(Lmin[1]))
      return Lmin[1];
    if ( y > NumberTraits<Abscissa>::castToDouble(Lmax[1]))
      return Lmax[1];
     */
    
    return static_cast<Abscissa>( ceil(y));
  }
  else
  {
    ASSERT( (aQ[0] - aP[0]) != NumberTraits<Abscissa>::ZERO);
    slope = (aQ[1]-aP[1])/static_cast<double>((aQ[0] - aP[0]));
    double x = (Lmin[1] - aP[1] + slope*aP[0]) / slope;
   //trace.info()<<"y="<<y<<" ";
  /*  if ( x < NumberTraits<Abscissa>::castToDouble(Lmin[0]))
      return Lmin[0];
    if ( x > NumberTraits<Abscissa>::castToDouble(Lmax[0]))
      return Lmax[0];
    */
    return static_cast<Abscissa>( ceil(x));
  }
}
///////////////////////////////////////////////////////////////////////////////
template <typename TSpace>
inline
typename DGtal::ChamferNorm2D<TSpace>::ConstIterator
DGtal::ChamferNorm2D<TSpace>::getCone(const Vector &aDirection,
                                      ConstIterator aBegin,
                                      ConstIterator aEnd) const
{
  return std::upper_bound(aBegin, aEnd , canonicalRay(aDirection), myLessThanAngular) - 1;
}
///////////////////////////////////////////////////////////////////////////////
template <typename TSpace>
inline
typename DGtal::ChamferNorm2D<TSpace>::Vector
DGtal::ChamferNorm2D<TSpace>::canonicalRay(const Vector &aRay) const
{
  return Vector( (aRay[0]<0)? -aRay[0]:aRay[0], aRay[1] );
}
///////////////////////////////////////////////////////////////////////////////
template <typename TSpace>
inline
typename DGtal::ChamferNorm2D<TSpace>::Value
DGtal::ChamferNorm2D<TSpace>::operator()(const Point &P,
                                         const Point &Q) const
{
  Vector ray = canonicalRay(Q - P);
  
  //The cone
  ConstIterator it = getCone(ray, myDirections.begin(), myDirections.end());

 /* trace.info() << "   getting cone "<< *it<<std::endl;
  trace.info() << "   can. ray = "<< ray<<std::endl;
 */
  
  if ((it+1) == myDirections.end()) //aligned with Y axis
    --it;
  
  size_t pos = it - myDirections.begin();
  
  // v = dir_i/w_i
  Vector normalDir = myNormals[pos];
  
  //distance as the scalar product with the associated normal
  return ray[0]*normalDir[0] + ray[1]*normalDir[1];
}
///////////////////////////////////////////////////////////////////////////////
template <typename TSpace>
inline
typename DGtal::ChamferNorm2D<TSpace>::ConstIterator
DGtal::ChamferNorm2D<TSpace>::shrinkPSubMask(ConstIterator aBegin,
                                             ConstIterator aEnd,
                                             const Vector &aP, const Vector &aQ,
                                             const Point &Lmin, const Point &Lmax,
                                             const Dimension aDimension) const
{
  ASSERT(Lmin[aDimension] < Lmax[aDimension]);
  ASSERT(Lmin[(aDimension+1) %2] == Lmax[(aDimension+1)%2]);
  ASSERT(aP[(aDimension+1) %2] <=Lmin[(aDimension+1) %2]);
  ASSERT(aDimension == 1);
  
  trace.beginBlock();
  trace.info()<<"Checking "<<*aBegin<<" -- "<< *aEnd << "  adimension="<<aDimension<<std::endl;
  
  if ((aEnd- aBegin) > 1)
  {
    //Mid
    ConstIterator mid = aBegin + (aEnd - aBegin) / 2;
    
    trace.info() << "Mid direction= "<<*mid<<std::endl;
    trace.info() << "Mid+1 direction= "<<*(mid+1)<<std::endl;
    
    //beginPoint, endPoint
    Point midPoint,nextMidPoint;
    Abscissa upperBegin,lowerEnd;
    
    midPoint = aP + (*mid);
    nextMidPoint = aP + *(mid+1);
    upperBegin = getUpperRayIntersection(aP, midPoint, Lmin, Lmax, aDimension);
    lowerEnd = getLowerRayIntersection(aP, nextMidPoint, Lmin, Lmax, aDimension);
    
    midPoint = Lmin;
    midPoint[aDimension] = upperBegin;
    nextMidPoint = Lmin;
    nextMidPoint[aDimension] = lowerEnd;
    
    //Distances w.r.t. Q, O(log(n)) per distance
    double dmidQ = this->operator()(aQ, midPoint);
    double dnextmidQ = this->operator()(aQ, nextMidPoint);

    //Distance w.r.t. P, O(1) per distance
    size_t pos = mid - myDirections.begin();
    Vector normalDir = myNormals[pos];
    double dmidP = midPoint[0]*normalDir[0] + midPoint[1]*normalDir[1];
    normalDir = myNormals[pos+1];
    double dnextmidP = nextMidPoint[0]*normalDir[0] + nextMidPoint[1]*normalDir[1];
    
    trace.info() << "Instersections  mid="<<midPoint<<"  and mid+1="<< nextMidPoint << std::endl;
    
    trace.info() << "Distances : P->("<<dmidP<<","<<dnextmidP<<")   Q->("<<dmidQ<<","<<dnextmidQ<<")" << std::endl;
    bool PcloserMid = (dmidP < dmidQ);
    bool PcloserNextMid = (dnextmidP < dnextmidQ);
    
    trace.info() << " mid in "<< (PcloserMid ? "P":"Q") <<"  and mid+1 in "<< (PcloserNextMid ? "P":"Q")<<std::endl;
    
    //We have localized the cone
    if (PcloserMid != PcloserNextMid)
    {
      trace.endBlock();
      return aBegin;
    }
    
    //We decide to which direction we need to recurse
    if ((dmidQ <= dnextmidQ) && (dmidP <= dnextmidP))
    {
      trace.info()<<"Recurse down"<<std::endl;
      ConstIterator c = shrinkPSubMask(aBegin, mid, aP, aQ, Lmin, Lmax, aDimension);
      trace.endBlock();
      return c;
    }
    else
    {
      trace.info()<<"Recurse up"<<std::endl;
      ConstIterator c = shrinkPSubMask(mid,aEnd,aP, aQ, Lmin, Lmax, aDimension);
      trace.endBlock();
      return c;
    }
  }
  
  return aBegin;
  trace.endBlock();
  
}
///////////////////////////////////////////////////////////////////////////////
template <typename TSpace>
inline
typename DGtal::ChamferNorm2D<TSpace>::ConstIterator
DGtal::ChamferNorm2D<TSpace>::shrinkP(ConstIterator aBegin,
                                      ConstIterator aEnd,
                                      const Vector &aP, const Vector &aQ,
                                      const Point &Lmin, const Point &Lmax,
                                      const Dimension aDimension) const
{
  ASSERT(Lmin[aDimension] < Lmax[aDimension]);
  ASSERT(Lmin[(aDimension+1) %2] == Lmax[(aDimension+1)%2]);
  
  Point P,Q, Lm, LM;
  
  P = aP;
  Q = aQ;
  Lm = Lmin;
  LM = Lmax;
  
  if (aDimension == 1)
    if (aP[0] > Lmin[0])
      P[0] = Lmin[0] - (aP[0] - Lmin[0]);
  
  
  if (aDimension == 0)
  {
    Q[0] = aQ[1] ; Q[1] = aQ[0];
    P[0] = aP[1] ; P[1] = aP[0];
    Lm[0] = Lmin[1] ; Lm[1] = Lmin[0];
    LM[0] = Lmax[1] ; LM[1] = Lmax[0];
    
    if (P[0] > Lm[0])
      P[0] = Lm[0] - (P[0] - Lm[0]);
  }
  
  return shrinkPSubMask(aBegin, aEnd, P, Q, Lm, LM, 1);
}
///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions                                        //
template <typename TSpace>
inline
std::ostream&
DGtal::operator<< ( std::ostream & out,
		  const ChamferNorm2D<TSpace> & object )
{
  object.selfDisplay( out );
  return out;
}
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
